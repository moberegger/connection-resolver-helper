# `connection-resolver-helper`

The [Relay Connection specification](https://relay.dev/graphql/connections.htm) has become the de facto standard for GraphQL pagination implementations. The problem is that actually _writing_ these things can be verbose and somewhat nuanced; you must handle pagination arguments, map results to the correct schema shape, validate cursors, and so on... then rinse and repeat for all connection fields.

`connection-resolver-helper` intends to easily handle all boilerplate to make resolvers for Relay connections in Apollo Server, GraphQL Yoga, Mercurius, or any schema first implementation of your choosing.

Inspired by [`graphql-relay-js`](https://github.com/graphql/graphql-relay-js).

## Installation

You can use `npm`, `yarn`, or any package manager of your choosing. To install via `npm`

```bash
npm install connection-resolver-helper graphql
```

Note that `graphql` is a peer dependency. Any version greater than `14` is supported. Older versions will still likely work, but

## Quick Start

Let's say you have a GraphQL API to retrieve all books in your library. A simple root level query to paginate over all books would look something like:

```graphql
type Query {
  "Books in the library."
  books(
    "Return the first n elements from the list."
    first: Int
    "Return the last n elements from the list."
    last: Int
    "Return the elements in the list that come after the specified cursor."
    after: String
    "Return the elements in the list that come before the specified cursor."
    before: String
  ): BookConnection
}

"A list of books in the library."
type BookConnection {
  "A list of edges to books."
  edges: [BookEdge!]

  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge to a book."
type BookEdge {
  "The book on the edge."
  node: Book

  "A cursor for use in pagination."
  cursor: String!
}
```

This is a standard connection as per the [Relay specification](https://relay.dev/graphql/connections.htm). You now need to implement a `books` resolver that can handle accepting pagination arguments, validating them, return the correct page based on those arguments, and ensure that the connection, edges, and nodes can all resolver.

With `connection-resolver-helper` you can simply

```typescript
import { connection } from "connection-resolver-helper";

const resolvers = {
  Query: {
    books: connection((_, args, ctx) => ctx.models.Book.findAll()),
  },
};
```

## How it works

`connection-resolver-helper` makes no assumptions about how the downstream data source fetches the data - you can give it just the required page, the entire possible page set, or even the entirety of the data collection; it will just figure it out for you!

You can think of this as "auto pagination". When data is fed into the connection, the `before` and `after` cursors will be used to slice data into a possible page set (ie. the data to be paginated over). Note that this doesn't mean that both cursors _must_ be provided; no `before` cursor means "until end of data set", and likewise, no `after` cursor means "form beginning of data set". The provided data will be traversed to find the appropriate cursors to ensure that the correct subset of data is being dealt with.

A page is returned based on either `first` or `last` value provided to the connection (note that only one or the other is valid). More specifically, this means grabbing the `first` n _or_ `last` n elements of the possible page set as per the provided cursors. This page is then mapped to the correct shape to be picked up by resolvers. This includes mapping to `edges`, `node`s and `cursor`s, and generating the correct `pageInfo`. This is all done lazily so that the cost to do any of these steps is only paid a single time on demand. For example, if `pageInfo` is not in the GraphQL query, the logic to resolve it will never run.

The `pageInfo` values are automatically generated by comparing the current page to the possible page set. `startCursor` and `endCursor` are simply the first and last cursors on the current page. `hasNextPage` will compare the last cursor of the current page to the final cursor of the entire page set to determine if there is another page, and likewise for `hasPreviousPage`.

And that's about it, really! It's simply glorified boilerplate so that you don't have to write the above logic over and over again.

## Features

- Validates pagination arguments
- Validates cursors
- Automatically slices correct page regardless of data provided
- Maps to connection spec
- Calculates page info
- `nodes` shortcut
- `totalCount`
- Lazy evaluation and memoization
- Configurable - higher order function for reusable configurations
- Just a regular old resolver

## API

### `connection`

A higher order resolver with the [default configuration options](#configuration-options) intended to get you started as quickly as possible. This accepts a regular ol' resolver (matching [`graphql`](https://github.com/graphql/graphql-js)'s [`GraphQLFieldResolver`](https://github.com/graphql/graphql-js/blob/main/src/type/definition.ts#L879) type), and returns a resolver that simply augments it with all of the pagination [magic](#how-it-works).

```typescript
import { connection } from "connection-resolver-helper";

const resolvers = {
  Query: {
    books: connection((_, args, ctx) => ctx.models.Book.findAll()),
  },
};
```

### `makeConnection`

A function that accepts a set of [configuration options](#configuration-options) and returns a higher order resolver (ie. another function that accepts a regular ol' resolver (matching [`graphql`](https://github.com/graphql/graphql-js)'s [`GraphQLFieldResolver`](https://github.com/graphql/graphql-js/blob/main/src/type/definition.ts#L879) type).

An example with an exhaustive set of options would look like:

```typescript
import { makeConnection } from "connection-resolver-helper";

const resolvers = {
  Query: {
    books: makeConnection({
      maxLimit: 100,
      paginationRequired: true,
      disableBackwardsPagination: false.
      toCursor: (node) => Buffer.from(node.id, 'utf8').toString('base64'),
      validateCursor: (cursor) => cursor.length > 0,
      getTotalCount: (root, data) => data.length,
    })((_, args, ctx) => {
      return ctx.models.Book.findAll();
    }),
  },
};
```

Now, you might be wondering why `makeConnection` returns _another_ function rather than simply accepting a configuration object with your resolver. This is because your API will likely have a consistent set of configurations that you don't want to repeat over and over. Let's say for example you'd like to pagination to be optional across your entire API. Instead of having to provide the [`paginationRequired`](#paginationrequired) option over and over again like:

```typescript
import { makeConnection } from "connection-resolver-helper";

const resolvers = {
  Query: {
    books: makeConnection({
      paginationRequired: false,
    })((_, args, ctx) => {
      return ctx.models.Book.findAll();
    }),

    authors: makeConnection({
      paginationRequired: false,
    })((_, args, ctx) => {
      return ctx.models.Author.findAll();
    }),
  },
};
```

you can export a single helper like:

```typescript
// In my-connection.ts ...
import { makeConnection } from "connection-resolver-helper";

export const paginationOptionalConnection = makeConnection({
  paginationRequired: false,
});

// Elsewhere...
import { paginationOptionalConnection } from "./my-connection";

const resolvers = {
  Query: {
    books: paginationOptionalConnection((_, args, ctx) => {
      return ctx.models.Book.findAll();
    }),

    authors: paginationOptionalConnection((_, args, ctx) => {
      return ctx.models.Author.findAll();
    }),
  },
};
```

In fact, the [`connection`](#connection) API above is simply doing this with the [default configuration](#configuration-options).

#### Configuration options

| Option                       | Type             | Description                                                            | Default                                   |
| ---------------------------- | ---------------- | ---------------------------------------------------------------------- | ----------------------------------------- |
| `maxLimit`                   | Positive integer | The maximum value allowed for either `first` or `last` args.           | `100`                                     |
| `paginationRequired`         | Boolean          | Whether or not the connection requires either a `first` or `last` arg. | `true`                                    |
| `disableBackwardsPagination` | Boolean          | Disable the use of the `last` arg .                                    | `false`                                   |
| `toCursor`                   | Function         | A function that returns an opaque cursor for each node.                | Base 64 encodes the index of the node     |
| `validateCursor`             | Function         | A function that validates `after` and `before` args.                   | Ensure cursor is a non-empty string       |
| `getTotalCount`              | Function         | A function that returns the total number of nodes in a connection.     | The `length` of data returned by resolver |

#### `maxLimit`

The maximum value allowed for either `first` or `last` arguments.

If a client attempts to query a connection when either `first` or `last` is greater than the `maxLimit`, a [`GraphQLConnectionError`](#graphqlconnectionerror) will be thrown.

#### `paginationRequired`

Whether or not the connection requires either a `first` _or_ `last` arguments. Whilst `after` and `before` are always optional, one of `first` _or_ `last` is required. Be aware that `first` and `last` _cannot_ be provided together; this will result in an error. This is because you cannot simultaneously do forwards and backwards pagination. Whilst the specification doesn't forbid this, it heavily [discourages it](https://relay.dev/graphql/connections.htm#note-a97ec).

If `paginationRequired` is `false`, this will allow clients to omit all arguments to retrieve all data in the connection. Sometimes this flexibility is desirable, particularly if you are migrating your API to connections and would like to ease the refactor path for your clients.

If a client attempts to query a connection with an invalid set of pagination arguments when `paginationRequired` is `true`, a [`GraphQLConnectionError`](#graphqlconnectionerror) will be thrown. Please note that since all arguments are optional in the schema, this input validation must be done in the resolver.

#### `disableBackwardsPagination`

If `true`, this will disable the ability to backwards paginate, effectively forbidding the use of the `last` argument. This might seem like an odd feature to enable, but for many apps the use case for backwards pagination isn't mission critical, and requiring developers to implement backwards pagination in a downstream SQL query or REST API isn't ideal. For example, infinite scroll only requires forwards pagination to work, and you can save effort by setting `disableBackwardsPagination` to `false` _just in case_ a client attempts to pagination backwards. Defaults to `false`.

If a client attempts to paginate backwards when `disableBackwardsPagination` is `false`, a [`GraphQLConnectionError`](#graphqlconnectionerror) will be thrown.

The recommended way of disabling backwards pagination is by simply omitting the `last` argument in your schema. This makes it so that a client _can't_ provide a `last` argument in a valid query.

```graphql
type Query {
  "Books in the library."
  books(
    "Return the first n elements from the list."
    first: Int
    "Return the elements in the list that come after the specified cursor."
    after: String
    "Return the elements in the list that come before the specified cursor."
    before: String
  ): BookConnection
}
```

The `disableBackwardsPagination` option is available to you in case you do any schema linting that validates against the Relay Connection spec (for example, with [`graphql-schema-linter`](https://github.com/cjoudrey/graphql-schema-linter). while it would be preferable to customize your linting rules to accommodate this, that can be difficult to do, so this option can be used as an escape hatch of sorts.

#### `toCursor`

A function that accepts a node, fields arguments, and index, and returns an opaque string.

```typescript
type ToCursorFunction<Node> = (
  node: Node,
  args: ConnectionArguments,
  index: number
) => string;
```

The result of this function will used as the value for each `cursor` field on the edge. By default,

If you are unsure what to do here, a good option is to simply base64 encode the node's id.

```typescript
export const toCursor = (node) => {
  return Buffer.from(node.id, "utf8").toString("base64");
};
```

#### `validateCursor`

#### `getTotalCount`

```typescript
type GetTotalCountFunction<Root, Node> = (
  root: Root,
  node: Node[],
  args: ConnectionArguments
) => number;
```

Perhaps a more idiomatic way of accomplishing this would be to simply provide your own `totalCount` resolver on your connection 0 - these are just regular types and resolvers after all!

```graphql
"A list of books in the library."
type BookConnection {
  # Other connection fields...

  # The total number of books in the library.
  totalCount: Int
}
```

```typescript
const resolvers = {
  BookConnection: {
    totalCount: (_, args, ctx) => ctx.models.Book.countAll(),
  },
};
```

`getTotalCount` is available to you if you prefer to keep the `totalCount` resolver co-located with the rest of your connection.

### `GraphQLConnectionError`

## Examples

- custom connection field
- custom edge field
- reusable config (with overrides?)

## Contributing

Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

Please make sure to update tests as appropriate.

## License

[MIT](https://choosealicense.com/licenses/mit/)
